* PDP11 机器特性

** PDP-11的特征概要

  - 指令和数据基本都是16比特为单位进行的
  - 总线名为Unibus,具有18比特宽的地址总结
  - 以Word或byte为单位进程处理
  - 异步操作
  - 模块化组件
  - 栈处理
  - 自动化优先级处理

** 硬件相关

*** 通用寄存器
#+CAPTION: PDP-11通用寄存器
#+NAME:   tab:basic-data
| 名称  | 数量  | 别名  | 描述                             |
|------+------+------+-----------------------------------|
| r0   |  1   |      | 用于运算、函数的返回值：1,表达式求值时作为临时累加器. 2, 在过程返回时存放返回值. 3,在过程调用的*某些情况*下传参(更多的其实是用栈了) |
| r1   |  1   |      | 同 r1                           |
| r2   |  1   |      | 本地处理。在过程调用时用作局部变量.在过程调用入口处存放这些值,在过程调用结束时要恢复这些值，在CSV， RSV方法中有这些操作 |
| r3   |  1   |      | 同 r2                           |
| r4   |  1   |      | 同 r2                           |
| r5   |  1   |      | 帧指针或环境指针,用作过程激活记录动态链的链首指针            |
| r6   |  2   | sp   | 栈指针,它有 =两份= ：用户态、核心态下各一份(stack pointer) |
| r7   |  1   | pc   | 程序计数器,也叫指令地址寄存器(program count)，处理器从r7指示的内存地址中读取指令，随后解释并执行该指令，处理完后r7将指向容纳下一条指令的内存地址 |

非常要记住的就是SP，它是在内核模式和用户模式下，它各有一个。内核SP指向内核虚拟空间，用户SP指向用户虚拟空间。


在 =/root/usr/sys/reg.h= 中定义了每个register所对应的地址，一般是用来给user结构体使用的。

#+BEGIN_SRC C
/*
 * Location of the users' stored
 * registers relative to R0.
 * Usage is u.u_ar0[XX].
 */
#define	R0	(0)
#define	R1	(-2)
#define	R2	(-9)
#define	R3	(-8)
#define	R4	(-7)
#define	R5	(-6)
#define	R6	(-3)
#define	R7	(1)
#define	RPS	(2)
#define	TBIT	020		/* PS trace bit */
#+END_SRC

=PSW= 指 =processor status word= 是处理器状态字, =PSD= 是一个被称为处理器状态字的16位寄存器，Processor Status Word PSW (at 0777776)

PSW寄存器位于内核最高地址0777776处，它只能在内核模式下被访问到。


#+CAPTION: PSW 处理器状态字各字段的含义
#+NAME:   tab:basic-data
|  比特位    |              含义                                               |
| --------- | ---------------------------------------------------------------|
|   15-14   | 处理器当前模式, 00为内核模式, 11为用户模式,永远不出现01或10的情况           |
|   13-12   | 处理器先前模式, 00为内核模式, 11为用户模式,永远不出出现01或10的情况           |
|   11-8    | 保留位                                                       |
|   7-5     | 处理器优先级, 因为是3位，所以优先级是0-7                          |
|   4       | trap位                                                        |
|   3       | N 负位                                                        |
|   2       | Z 零位                                                        |
|   1       | V 溢出位                                                       |
|   0       | C 借位                                                        |



** Memory Mapped IO (内存映射I/O)

  PDP-11/40以及周边设备的寄存器被映射到内存最高的8KB空间, 因此都采用操作内存相同的方法来操纵寄存器.这种方法叫做 =内存映射I/O(Memory Mapped I/O)= 。

  最高位的8K字节是作为输入,输出设备界面寄存器的编址(也包括外理器中的各个寄存器),这个称为输入,输出页.

  =PDP-11/40= 把内核虚拟地址空间中的 0x0~0xF8 保留作为中断向量表区域;0xF8~0x400 作为中断服务函数空间。把内核虚拟地址空间中最高的 8K 地址空间(56K~64K)保留作为 外设的寄存器和其他通用寄存器空间。所有这些地址空间只有在内核模式下才能访问。

  PDP 11/40 对大多数外部设备(Peripheral)都用一套类似的寄存器进行管理:

  - 控制和状态寄存器，它主要用来控制外设的操作，并且记录外设操作的状态和结果。

  - 数据缓冲寄存器 它主要用来存储外设操作所需要的数据。

** MMU、地址总线、 虚拟内存

  =MMU= 是 =Memory Management Unit= ，即内存控制单元。

  PDP-11/40 拥有 =18位的寻址能力= ，即地址总线宽度为18位， 所以理论上程序可以达到 =256K - 8K = 248K= 的内存地址(即内存可以做成 =248KB= 大小的)。 总线具有很高的数据传输速率，其最大传输速率达到 =40Mbit/s= （当前计算机前端传输速率可达1033Mbit/s，最新型I/O总线PCI-Express则可达102.4Gbit/s）。248KB的内存地址是物理存在的,因为地址总结有这样的寻址能力。

  用MMU进行管理时,使用的是 =16位的虚拟地址= 。因为虚拟地址有16位,所以程序拥有 =64KB= 的空间,它被分为8页,每页长 =8KB= 。



*** 虚拟内存地址的结构

#+BEGIN_SRC ditaa :file assets/virtual-address.png :cmdline -r :exports results

+--------------+  +----------------------------------+  +-----------------------------+
|              |  |                                  |  |                             |
|     APF      |  |                BN                |  |              DIM            |
|              |  |                                  |  |                             |
+--------------+  +----------------------------------+  +-----------------------------+
       |                           |                                    |
       v                           v                                    v
+--------------+  +----------------------------------+  +-----------------------------+
|              |  |                                  |  |                             |
| 15 | 14 | 13 |  | 12 | 11 | 10 |  9 |  8 |  7 |  6 |  |  5 |  4 |  3 |  2 |  1 |  0 |
|              |  |                                  |  |                             |
+--------------+  +----------------------------------+  +-----------------------------+

#+END_SRC


上图描述了一个虚拟地址的三个部分

  - =APF= 指 =active page field= 活动页字段,  是 =15 ~ 13= 位,这样能表达 =8(2^3)= 个不同的状态,所以有 =8页= 。

  - =BN= 指 =Block Number= 是每页分成的  =128(2^7)= 个字符块, 每个字符块长度为`64`字节.

  - =DIB= 指 =distant indent block= 每个字符块中的偏移量。

虚地址必须要转化为实际物理地址,这步工作是通过 =MMU= 来进行管理的。 =MMU= 分两组，一组是核心态，一组是用户态， 每组都有8个 =APR= ， 都是通过 =PSW= 进行切换的。


*** 虚地址如何转换为实际的物理地址?

1. 根据运行的状态选择相就的活动页寄存器组(内核态,用户态)

1. 根据虚拟地址的APF选择一组活动的页寄存器 =APR=

1. 被选到的 =PAR= 的 =PAF= 表示了这一页在内存中的起始块号, PAR中的前四位没有用到，只用到了后面的12位

1. 虚拟地址字中的 =BN= 加上 =PAR= 中的 =PAF= 字段,得到的就是物理地址的块号

1. 虚拟地址中的 =DIB= 与物理块号相连,就构成了真正的18位物理地址


#+BEGIN_SRC ditaa :file assets/virtal-address-to-physical-address.png :cmdline -r :exports results

                                                                               Virtual Address

                                               +--------------+  +------------------------------+  +-----------------------+
                                               |              |  |                              |  |                       |
                                               | 15 | 14 | 13 |  | 12 | 11 | 10 | 9 | 8 | 7 | 6 |  | 5 | 4 | 3 | 2 | 1 | 0 |
                                               |              |  |                              |  |                       |
                                               +--------------+  +------------------------------+  +-----------------------+
                                                       |                                    |                         |
                                                       |                                    |                         |
           +-------------------------------------------+                                    |                         |
           |                                                                                |                         |
           v                                                                                |                         |
+-------------------+  +-------------------------------------------------+                  |                         |
|                   |  |                                                 |                  |                         |
| 15 | 14 | 13 | 12 |  | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |                  |                         |
|                   |  |                                                 |                  |                         |
+-------------------+  +-------------------------------------------------+                  |                         |
                                                       |                                    |                         |
                                                       |                                    |                         |
                                                       |                                    |                         |
                                                       |                                    |                         |
                                                       |                +-----+             |                         |
                                                       +------------->  | ADD |  <----------+                         |
                                                                        +-----+                                       |
                                                                           |                                          |
                                                                           v                                          v
                                        +-------------------------------------------------------+  +-----------------------+
                                        |                                                       |  |                       |
                                        | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 |  | 5 | 4 | 3 | 2 | 1 | 0 |
                                        |                                                       |  |                       |
                                        +-------------------------------------------------------+  +-----------------------+

                                                                                            physical Address
#+END_SRC


** psw 与 MMU

psw 中14，15决定了是用户态还是内核， pdp11/40提供了两种处理器模块，内核态和用户态，他们的区别在于：

  - 在进行虚拟内存映射时，两个模式各使用一套独立的内存映射器。

  - 指令的操作权限有差别，这样可以做到保持操作系统内核。

#+BEGIN_SRC ditaa :file assets/mmu-psw.png :cmdline -r :exports results
+-----------------------------+
| 15 14  |                    |
+-----------------------------+
    |
    +-------------------+
    |                   |
    v                   v
  +----+             +----+
  | 00 |             | 11 |
  +----+             +----+

+-----------+    +-----------+
|           |    |           |
|   Kernel  |    |   User    |
|           |    |           |
|           |    |           |
|   APR 0   |    |   APR 0   |
|           |    |           |
|   APR 1   |    |   APR 1   |
|           |    |           |
|   APR 2   |    |   APR 2   |
|           |    |           |
|   APR 3   |    |   APR 3   |
|           |    |           |
|   APR 4   |    |   APR 4   |
|           |    |           |
|   APR 5   |    |   APR 5   |
|           |    |           |
|   APR 6   |    |   APR 6   |
|           |    |           |
|   APR 7   |    |   APR 7   |
|           |    |           |
+-----------+    +-----------+
#+END_SRC

另一个角度来看待MMU

  - SSR0是“启动位”，操作员？因为在操作员启动系统时，他通常会触发终端的“清除”按钮，从而把SR0 寄存器清成0。所以，在正常启动时，MMU 应该是被关闭的。另外，最重要的一点是：在双总线超时错的情况下，CPU 将转移到地址0 处执行，也就会跳转到start 函数中执行，而这时MMU 是被打开的。所以，在系统启动时，如果MMU 打开，表明系统已出错，程序则不应该继续执行

  - SSR0, SSR2为状态和错误指示寄存器

#+BEGIN_SRC ditaa :file assets/mmu-psw2.png :cmdline -r :exports results
+-------------------------+
| 0o177572 | 65402 | SSR0 |
+-------------------------+
| 0o177576 | 65406 | SSR2 |
+-------------------------+


                           +-----------------------------+
                           | 15 14  |                    |
                           +-----------------------------+
                                          |
                               +-------------------+
                               |                   |
                               v                   v
                   +-----------+                   +-----------+
                   |           |                   |           |
                   |     00    |                   |    11     |
                   |   Kernel  |                   |   User    |
                   |           |                   |           |
                   +-----------+                   +-----------+


+---------------+    +---------------+        +---------------+    +---------------+
| 62688 | KISA0 |    | 62656 | KISD0 |        | 65440 | UISA0 |    | 65408 | UISD0 |
| 62690 | KISA1 |    | 62658 | KISD1 |        | 65442 | UISA1 |    | 65410 | UISD1 |
| 62692 | KISA2 |    | 62660 | KISD2 |        | 65444 | UISA2 |    | 65412 | UISD2 |
| 62694 | KISA3 |    | 62662 | KISD3 |        | 65446 | UISA3 |    | 65414 | UISD3 |
| 62696 | KISA4 |    | 62664 | KISD4 |        | 65448 | UISA4 |    | 65416 | UISD4 |
| 62698 | KISA5 |    | 62666 | KISD5 |        | 65450 | UISA5 |    | 65418 | UISD5 |
| 62700 | KISA6 |    | 62668 | KISD6 |        | 65452 | UISA6 |    | 65420 | UISD6 |
| 62702 | KISA7 |    | 62670 | KISD7 |        | 65454 | UISA7 |    | 65422 | UISD7 |
+---------------+    +---------------+        +---------------+    +---------------+
#+END_SRC

下面介绍一下 =APR= ,一个 =APR= 由一个 =PAR 页地址寄存器= 和一个 =PDR 页描述寄存器=  组成。

#+BEGIN_SRC ditaa :file assets/apr-desc.png :cmdline -r :exports results

+----------------------------------------------------------------------+
|                                                                      |
|                     APR (Activate Page Register)                     |
|                                                                      |
+----------------------------------------------------------------------+

                                   |
                                   v

+---------------------------------+  +---------------------------------+
|                                 |  |                                 |
|   PAR (page Address register)   |  | PDR (page description Register) |
|                                 |  |                                 |
+---------------------------------+  +---------------------------------+
#+END_SRC

=PAR= 指 =page address register= 真正用到的其实只有 =0 ~ 11= 位，这12位被称为 =PAF 页地址字段= ， 它说明的是虚拟地址空间中相应页在物理空间中的基地址，单位是内存字符块，所以它的寻址范围是 =0 ~ (2^12 -1 )* 64= ， 即 =0 ~ (256K - 64)= 字节。


#+BEGIN_SRC ditaa :file assets/par-desc.png :cmdline -r :exports results

+----------------------------------------------------------------------------------+
|                                                                                  |
|                        PAR                                                       |
|                                                                                  |
+----------------------------------------------------------------------------------+


+-------------------+  +-----------------------------------------------------------+
|                   |  |                        PAF                                |
|                   |  |                                                           |
| 15 | 14 | 13 | 12 |  | 11 | 10 |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |
|                   |  |                                                           |
+-------------------+  +-----------------------------------------------------------+

#+END_SRC


=PDR= 指 =page description register= ， 是页说明寄存器，它包含了页长， 存取方式和扩展方向等信息，它的结构如下:

#+BEGIN_SRC ditaa :file assets/virtual-address.png :cmdline -r :exports results

        +----------------------------------+          +----+               +----+  +---------+
        |                                  |          |    |               |    |  |         |
        |                PLF               |          |  W |               | ED |  |   ACF   |
        |                                  |          |    |               |    |  |         |
        +----------------------------------+          +----+               +----+  +---------+
                          |                              |                    |         |
                          v                              v                    v         v
+----+  +----------------------------------+  +----+  +----+  +---------+  +----+  +---------+  +----+
|    |  |                                  |  |    |  |    |  |         |  |    |  |         |  |    |
| 15 |  | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  |  7 |  |  6 |  |  5 |  4 |  |  3 |  |  2 |  1 |  |  0 |
|    |  |                                  |  |    |  |    |  |         |  |    |  |         |  |    |
+----+  +----------------------------------+  +----+  +----+  +---------+  +----+  +---------+  +----+

#+END_SRC

- =PLF= 指 =page length field= 它说明的是虚拟页的使用长度(字符块数量)。变化范围是 =1 ~ 128= 。它的算法与 =ED= 相关。 若 =ED= 为0， 那么实际长度就是PLF的值加1，若PLF的值是0，那么实际使用的长度为1(至少要使用1页的吧!)。若 =PLF= 为127， 那么实际的长度是128。 如果 =ED= 为1,那么实际长度就是128减去 =PLF= 的值，即PLF为127,那么使用长度就是1.


- =W= 指 =write= 存取信息位， 表示相应的APR字最近一次装入后，这一页是否写过， =1= 表示进行过写操作，反之则否。如果有一页的内外存都有副本，那么在将内存副本作它用前，要检查一下这一页，如果其值为0，那就直接销毁。反之则要将内存中的这一页数据，移到外存当中，保证数据的正确性.

- =ED= 是扩展方向位，如果一个虚拟页实际使用长度小于128个内存字符块，那么就要用ED来说明这个页的空白部分是在低地址一侧还是高地址一侧。这也说明了如果要扩展这个虚拟页，是要从低地址向高地址扩展，还是从高地址从低地低扩展。在unix中，纯正文和数据段使用的是ED为0的情况，表示空白部分在高地址一端。而栈段使用提是ED为1的方式。扩充方向只对于实际使用小于128个内存字符块的虚页才有意义。

- =ACF= 指存取控制字段，它说明了该页的存取权。

#+CAPTION: ACF存取权说明
#+NAME:   tab:basic-data
| ACF     |  存取权      | 说明                     |
|---------+-------------+-------------------------|
| 00      | 不驻在内存    | 任何存取操作都会造成错误   |
| 01      | 只读         | 企图写操作会出错          |
| 10      | (未用)       | 任何存取操作都会造成错误   |
| 01      | 读写         |                         |


*** 寄存器

par, pdr在IO映射地址上不是相连的。

#+BEGIN_SRC C
#define	UISD	0177600		/* first user I-space descriptor register */
#define	UISA	0177640		/* first user I-space address register */
#define	UDSA	0177660		/* first user D-space address register */
#define	RO	02		/* access abilities */
#define	WO	04
#define	RW	06
#define	ED	010		/* extend direction */
#+END_SRC

** 其他信息


*** 面板寄存器 panel register (at 0777570)

- 面板寄存器

There are two panel registers: a read only switch register (SR), which mirrors the state of the panel switches, and a write only display register (DR) to control the panel lights.
有两种面板寄存器，一个是只读的开关寄存器，表着着面板上的开关状态.另一个是只写寄存器，用来控制面板上的灯

- 面板寄存器在电源关掉情况下

After power on, all but two registers are set to zero. The IPL in the PSW is set to 7 and the switch register is left as it is.

切断电源之后，这两种寄存器都会被置为0，但 =PSW= 中的 =IPL= 位会被设为7，其他都保留以前的状态。


*** RK05

[[http://en.wikipedia.org/wiki/RK05][PK05]] 是由 =DEC= 公司制作的一款移头式磁盘驱动设备，在14英寸的磁盒内存储了2.5MB的数据。

  The RK05 DECpack was a moving head magnetic disk drive manufactured by the Digital Equipment Corporation of Maynard, Massachusetts. It stored approximately 2.5 MB on a 14", single-platter IBM-2315-style front-loading removable disk cartridge. The cartridge permitted users to have relatively unlimited off-line storage and to have very fast access to such data.

  At the time DEC had numerous operating systems for each computer architecture so operating systems could also be changed quickly. The RK05 was the disk successor to DECtape for personal, portable, and expandable storage. While the smallest practical configuration was two drives, many systems had four or more drives.
