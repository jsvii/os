* 并发和并行


** 并发(Concurrency)和并行(Parallelism)的区别

最近在读《real world haskell》里关于并行的一章时，看到作者首先对并发(Concurrency)和并行(Parallelism)的区别进行了定义和解释。以前我对这个问题也是一知半解，如果有人问题这个问题，恐怕我只能挠头说不清楚。而在这本书里，作者的解释是(简单翻译)：

*** 并发

一个并发程序是指能同时执行通常不相关的各种任务。以一个游戏服务器为例子：它通常是有各种组件组成，每种组件都跟外部世界进行着复杂的信息交互。一个组件有可能要处理多个用户聊聊；另外一些可能要处理用户的输入，并把最新状态反馈给用户；其它的用来进行物理计算。这些都是并发处理。

并发程序并不需要多核处理器。

*** 并行

相比之下，并行程序是用来解决一个单一任务的。以一个试图预估某支股票价格在下一分钟波动情况的金融组件为例，如果想最快速度的知道标普500中哪知股票应该卖出还是买进，你不能一个一个的计算，而是将这些所有的股票同时计算。这是并行。

其实也不是很好懂，我自己琢磨了一下，大概是这个道理：并发就是一心二用(多用)，比如你一边听老师讲课，一边低头看课桌下韩寒的小说。这两件事你在同时做，而且这两件事并不一定需要相关。而并行就是兵分几路干同一个事情。比如别人看小说只能一行一行的看，而你能一目十行，这就是并行。:) 。

关于并发和并行的区别，Go语言有一个非常好的教材，叫做“并发不是并行”，它以Go语言为例，图文并茂的为我们讲解了并发和并行之间的联系和区别。

并发不是并行

** 并发(Concurrent) 与并行(Parallel) 的区别

刚开始阅读 《Akka IN ACTION》这本书，刚开始是对 Revolution 这个词翻译成中文是革命 感到诧异，因为革命 通俗来讲就是 杀人 的意思。至于 Revolution 英文解释不深究了，只是感叹何以颠覆性的变化就一定要杀人吗？

也由此引出了编程中经常面对的 Concurrent(名词为：Concurrency) 和 Parallel(名词为：Parallelism) 这两个词，基本上是认为它们是同一个意思。其实不然，下面慢慢道来。

如果从英文字对它们的解释也没有多大区别，差不多都是说同是发生，但字面上 Parallel 多了一个平行的意思。所以在中文上，在计算机领域我们约定的翻译是

Concurrent(Concurrency)  --  并发
Parallel(Parallelism)           --  并行

比如在多线程环境中它们的区别具体体现在：

并发：多个任务在同一个 CPU 核上按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。针对 CPU 内核来说，任务仍然是按细粒度的串行执行。也难怪在 Java 5 中新加的并发 API 的包名是 java.uti.concurrent。

并行：区别与串行，多个任务真正的分配到不同的 CPU 内核上去执行的，它们是真正的同时执行。注意到 Java 8 的  Collection 除了 stream() 方法外，还有个方法名字叫做  parallelStream(), 为什么它是 parallel 呢？因为它使用的线程池是 ForkJoinPool.commonPool, 而这个池的大小是 CPU 内核数减一，主线程已经占了一个核，希望 的是 parallelStream() 中每个任务都能理想的分配到不同的 CPU 内核上去并行执行。

更通俗一点的类比，并发是四辆汽车在同一个车道上跑; 并行是单向四车道，四辆车在各自的车道跑，彼此不受影响。

类似的概念也应用到了 sbt 或 Maven 执行所有测试用例的行为上，基于不同的配置：

测试并发执行 -- 所有测试用例逻辑上在同一个 JVM 上执行，默认行为好像就是这样的
测试并行执行 -- 所有测试用例可进行分组跑在多个的 JVM 上，更大程度上节约了测试时间
