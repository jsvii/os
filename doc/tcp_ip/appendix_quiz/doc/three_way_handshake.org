* 为什么是“三”次握手？

http://zhangshen147.online/post/handshake

TCP 是面向连接的协议，只有建立起了“虚拟”连接以后，才开始真正进入数据传输阶段，而且，当数据传输完成以后，最后还要释放连接，以避免计算机资源（如缓存区等）的浪费。也就是说，完整的 TCP 连接一共包括建立连接、传输数据和释放连接这 3 个完整的阶段。

其中“建立连接”阶段的实现依赖于三次握手的策略，但是为什么要这样设计，为什么不能是四次、五次，或者是两次握手呢？可能一些人就答不出来了。我曾见过有人说什么“四次太多，两次太少，三次刚刚好”这样的名言，试图用玄学去解决问题，emm，实在不能苟同。。今天我就想来深入讨论一下这个问题。

** 经典解释

考虑到记忆是会衰退的，所以就先带大家回顾一下三次握手的基本流程吧，话不多说，主要看图。不过在下面这张图中，我觉得我们应该注意几个细节。首先客户端和服务器端的地位是不相等的，一个是主动打开，一个是被动打开，而且相较于服务器端，客户端少了 LISTEN 这个阶段。其次，TCP 规定 SYN 报文段不能携带数据，但要消耗掉一个序号（FIN 也是），所以在 SYN 报文段后紧跟的 ACK 报文段中，其确认序列号 ack 的值都增加了 1，ACK 报文段可以捎带数据，也可以不捎带数据，如果捎带了的话，那么下次发送的报文段中的 seq 的值也应该相应地增加，如果没有捎带的话，那么下次发送的报文段中的 seq 的值则将不会发生任何变化，依旧是 x+1。

[[./img/handshake_3_times_1.png]]

然后接下来就开始真正地聊一下为什么一定要握三次手，而不是四次、五次吧。这个问题其实谢希仁老师在他主编的经典教材《计算机网络》中已经有所提及，不过却未能完全说服我，具体为什么还是等我们看了下面这段摘录以后再说吧：

#+BEGIN_QUOTE
为什么在建立连接阶段中，客户端 A 一定要发送最后一次 ACK 报文段，也就是三次握手中的最后一次握手呢？这主要是为了防止已失效的连接请求报文段突然又传到了服务器端 B，因而产生错误。

所谓“已失效的连接请求报文段”是这样产生的。考虑一种正常情况，客户端A发出连接请求，但服务器端B因连接请求报文段丢失而未收到确认，于是A只好再重新发送一次该连接请求报文段，这次一切正常，服务器端B收到了请求报文段，并紧跟着进行确认等，直至整个TCP流程走完（建立连接、传输数据，并释放连接）。在这个过程中，A 一共发送了两次连接请求报文段，其中的第一个在中途丢失，第二个顺利到达了服务器端 B，都不是“已失效的连接请求报文段”。

但考虑这样一种情况，假设 A 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间滞留了，以致延误到连接释放以后的某个时间段才到达 B。本来这是一个早已失效的报文段，但 B 对此却一无所知，收到后还误认为是 A 又重新请求建立的一个连接，于是就同意了，并回复给 A 一个确认报文段。假定不采用三次握手策略，而是只需要进行两次握手的话，那么此时只要 B 发出了这个确认报文段，那么它就认为新的连接已经建立了。

可现在由于 A 实际上并没有真的向 B 发出建立连接的请求，也没有进入 SYN-SENT 的状态，因此它不会理睬来自于 B 的确认。在这种情况下，A 并不会认为连接已经建立成功，也不会向 B 发送数据，但 B 却认为连接已经成功建立了，苦苦等待 A 向它发送数据，因此导致连接一直无法关闭，进而造成了资源浪费的问题。

注：“已失效的连接请求报文段”会导致资源浪费，但在这里，我们认为只有在连接释放以后到达的过期连接请求报文段才算是“已失效的连接请求报文段”。这是因为如果它到得太早，B 和 A 之间的连接还在的话，B 应该是会忽略这个新的建立连接请求的。
#+END_QUOTE

#+BEGIN_COMMENT
即理想的状态中只要两次

#+END_COMMENT

这种说法虽说勉强解释得通，但是却很难“服众”，因为在我看来，它只是举了一个反例而已，如果这样就可以的话，那么我想我应该也能举一个：

如果 3 次握手中的最后一次握手，也就是最后一个 ACK 报文没有发送成功的话，会发生什么情况呢？答案是会导致客户端 A 以为连接已经建立成功，然后一直发送数据、一直重传，导致资源浪费的情况出现呢。虽说问题出在客户端上，情况不像在服务器端上那么严重，但它明显还有问题的，农民的钱就不叫钱了吗？这就像“两军问题”一样无法避免。

因此，我认为谢老指出的不过是其中的一个方面，还没有真正解释出 3 次握手策略在设计时所真实面临的难题，尤其是感觉谢老太过忽视 TCP 连接全双工通信的这个事实。在我看来，三次握手问题的答案还是要继续往深处找，往 TCP 一些核心特性，比如说可靠传输、累计确认、全双工通信等身上找。

继续深入
我们都知道 TCP 和 UDP 之间最大的区别在于是否可靠传输，在我看来 TCP 协议之所以这么复杂的原因也在于此。TCP 为了实现可靠传输，将待传输的每段完整数据都看作是一个连续的字节流，也就是所谓的面向字节，然后引入连续 ARQ 以及其中的累积确认机制，二者结合共同弥补了停止-等待协议信道利用率不高的缺点。

面向字节要求我们给每个字节都编上号，只有这样我们才能准确地标识到每个字节，以方便重传那些丢失的或者乱序的数据；累计确认要求接收方必须也具有向发送方发送数据的能力，也就是所谓的全双工通信，因为只有这样接受端才能向发送端发送反馈，告诉发送端这次我收到的数据有多少字节是可靠的，对方是否需要对其中没收到的一些进行重传（隐藏信息），具体需要从哪个字节开始重传（隐藏信息）等。

注：有些人可能会对 TCP 的全双工产生疑问，因为真正的全双工指的是“在发送的同时也能够进行接收”，这意味着通信的双方至少要有两条线, 一条线用于发送，另一条线用于接收，这样才能达到“发送的同时也能接收”的目的。可是就目前的 TCP 而言，底层使用的大多都是以太网的协议和技术，可其中大多数局域网所使用的 CSMA/CD 又是与全双工冲突的，这算是怎么一回事呢？TCP 到底是不是全双工的呢？

但我认为其实是这样的，TCP 支持全双工通信指的是在传输层上面支持通信两端同时收发数据，但这同时也需要底层硬件和协议的支持，否则是无法实现真正意义上的全双工的。但由于网络是分层的、透明的，因此无论下层是否支持全双工，只要我们没有这个实际需求，是否是全双工的就对我们没有丝毫影响，反正 TCP 都可以正常运行。但有一点，无论是全双工还是半双工，至少它们都是支持双工通信的，都能在通信的两端之间互通有无，这是可靠传输要求进行反馈的基础，已经足够了。

要达到上面的一些要求，我们具体应该做些什么呢？首先需要给字节流编上号，可是该怎么编号呢？不管三七二十一都从 0 开始一直往后编吗？显然是不行的，因为如果每次都从一个固定的数值开始编码是有安全风险，容易遭受 SYN 洪泛攻击。现实的做法是使用计算机程序生成一个伪随机数作为起始序列号（Initial Sequence Number，ISN），这样就能保证 ISN 在全网范围的一定时间内不会重复了，这个时间非常久，几乎所有的数据包都撑不过去。

注：在数据传输阶段，如何防止延迟重复，靠的是防止序号回绕机制和滑动窗口协议。防止序号回绕机制除了指上面在一定时间内不会重复的 ISN 以外，还包括了最大报文段生存周期 MSL（Maximum Segment Lifetime），进一步确保了延迟的报文段一定会由于超时而被网络抛弃。滑动窗口协议指的是将接收到的小于当前序列号的延迟报文段给丢弃掉。

生成了 ISN 以后，问题的重点就来了，A 和 B 进行可靠通信，只有你 A 拥有这个由自己随机生成的 ISN 可不可以啊？显然是不可以的，你要发送给 B 才行，这样之后 A 再向 B 发送数据的时候，二者之间就可以通过序列号来进行沟通了。A 告诉 B 自己发送的这段字节是从哪里开始的，B 告诉 A 这段时间内自己实际收到的字节有多少，从而让 A 确定自己是否需要进行重传，简而言之就是通过累计确认机制来帮助实现可靠传输。

那么试想一下，A 要向 B 发送 ISN，只发送一次行不行？显然是不行的，可靠传输的核心实际上就是确认机制，无论是停止-等待协议，还是连续 ARQ 和滑动窗口协议，都要求接收方收到数据并（使用校验和）检查无误后，定时向发送方反馈一些确认报文段，好让发送方知道自己的数据是否已经被接收了。建立连接阶段作为整个 TCP 协议的重中之重，更应该必须做到这一点，因此最终结果就是，使用一对 SYN 和 ACK 报文来协商、传递过去一个 ISN 号码，也即进行了两次握手。

注：关于确认的必要性，我们还可以这样理解，通信双方进行可靠传输的必要条件是，双方都必须知道对方具备接收和发送数据的能力，如果对方不回复、确认的话，那么根本就无从核实起对方接收数据的能力。

来而不往非礼也，TCP 是全双工的，A 要向 B 发送数据，B 也要向 A 发送数据，因此这份工作要做 double，两次变成了四次，所以说一共应该需要进行四次握手。可事实上我们只进行了三次握手，这是因为协议把中间的那两次给合并在一起了，所有才会有了现在的三次握手，这已经是通信双方协商初始序列号的最低通信次数了，也是最必要的三次握手。

最后补充一点，只有在 A 到 B 的 ISN，以及返程的 B 到 A 的 ISN 都传递完毕以后，才算是真正地建立起了一条 TCP 连接，从来都没有半条 TCP 连接之说，因为只能单向进行通信的 TCP 由于无法完成确认、反馈工作，是无法保证可靠传输的。

总结扩展
总的来说，我们可以这样理解：每两次握手就能保证通信某方的一个 ISN 传递过去，而 TCP 又是全双工的，因此这个过程必须进行两次，也就是说 Alice 和 Bob（通信双方）都必须把各自生成的本地 ISN 传递过去才行。但是，这个过程被简化了，4 次握手经过合并和压缩，最终就变成了我们现在看到的 3 次握手的样子。

最后，再稍微发散一下 4 次挥手，4 次挥手在断开连接的时候无法进行合并，这两次操作必须分开进行，原因在于当 Alice 方提出“关闭连接”的时候，Bob 方可能还有少量的数据没发送完，如果强行关闭的话会造成难以预知的问题。所以，4 次挥手是必须的，它不能像 3 次握手那样被合并，一定要留给对方充足的准备时间以打扫残局才行。
